package redgear.brewcraft.plugins.nei;

import static net.minecraft.init.Items.potionitem;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.TreeSet;

import com.google.common.base.Function;
import com.google.common.collect.Iterables;

import cpw.mods.fml.common.FMLLog;
import org.apache.logging.log4j.Level;
import codechicken.nei.ItemStackSet;
import codechicken.nei.NEIClientUtils;
import codechicken.nei.NEIServerUtils;
import codechicken.nei.PositionedStack;
import codechicken.nei.api.API;
import codechicken.nei.api.IOverlayHandler;
import codechicken.nei.api.IRecipeOverlayRenderer;
import codechicken.nei.api.ItemFilter;
import codechicken.nei.recipe.BrewingRecipeHandler;
import codechicken.nei.recipe.GuiRecipe;
import codechicken.nei.recipe.ICraftingHandler;
import codechicken.nei.recipe.TemplateRecipeHandler;
import codechicken.nei.recipe.BrewingRecipeHandler.BrewingRecipe;
import codechicken.nei.recipe.BrewingRecipeHandler.CachedBrewingRecipe;
import codechicken.nei.recipe.TemplateRecipeHandler.CachedRecipe;
import codechicken.nei.recipe.TemplateRecipeHandler.RecipeTransferRect;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.inventory.GuiBrewingStand;
import net.minecraft.client.gui.inventory.GuiContainer;
import net.minecraft.init.Items;
import net.minecraft.inventory.Container;
import net.minecraft.item.ItemPotion;
import net.minecraft.item.ItemStack;
import net.minecraft.potion.Potion;
import net.minecraft.potion.PotionEffect;
import net.minecraft.potion.PotionHelper;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.StatCollector;
import net.minecraftforge.fluids.FluidRegistry;
import net.minecraftforge.fluids.FluidStack;
import redgear.brewcraft.core.Brewcraft;
import redgear.brewcraft.plugins.item.PotionPlugin;
import redgear.brewcraft.recipes.BreweryRecipe;
import redgear.brewcraft.recipes.RecipeRegistry;
import redgear.core.util.SimpleItem;

public class NEIBreweryRecipeHandler extends TemplateRecipeHandler {
	
	/*
	@Override
	public String getRecipeName() {
		return "Brewery";
	}
	*/
	public ArrayList<PositionedStack> recipestacks = new ArrayList<PositionedStack>();
	
	@Override
	public String getGuiTexture() {
		return new ResourceLocation("redgear_brewcraft:textures/gui/brewery.png").toString();
	}

    public class CachedBreweryRecipe extends CachedRecipe
    {
        public BreweryRecipe recipe;
        
        public CachedBreweryRecipe(BreweryRecipe recipe) {
            this.recipe = recipe;
        }
        
        @Override
        public ArrayList<PositionedStack> getIngredients() {
            recipestacks.add(new PositionedStack(new ItemStack(recipe.input.getFluid().getBlock()),32, 43));
            recipestacks.add(new PositionedStack(new ItemStack(recipe.item.getItem()), 32, 43));
            return recipestacks;
        }
        
        //This is clearly not implemented properly
        @Override
        public PositionedStack getResult() {
            return recipestacks.get(0);
        }
    }

    public static final ItemStackSet ingredients = new ItemStackSet();
    public static final HashSet<BreweryRecipe> apotions = new HashSet<BreweryRecipe>();

    @Override
    public void loadTransferRects() {
        transferRects.add(new RecipeTransferRect(new Rectangle(58, 3, 14, 30), "brewing"));
        transferRects.add(new RecipeTransferRect(new Rectangle(92, 3, 14, 30), "brewing"));
        transferRects.add(new RecipeTransferRect(new Rectangle(68, 23, 28, 18), "brewing"));
    }

    @Override
    public Class<? extends GuiContainer> getGuiClass() {
        return GuiBrewingStand.class;
    }
    
    
    @Override
    public String getRecipeName() {
    	String name = StatCollector.translateToLocal("RedGear.Brewcraft.Brewery");
    	FMLLog.log(Level.INFO, "You got the Brewcraft Stuff " + name);
        return name;
    }
    

    @Override
    public void loadCraftingRecipes(String outputId, Object... results) {
    	if (outputId.equals("brewing") && getClass() == NEIBreweryRecipeHandler.class) {//don't want subclasses getting a hold of this
    		FMLLog.log(Level.INFO, "Loading validated. Get ready... ");
    		RecipeRegistry recipes = PotionPlugin.getRecipeList();
    		FMLLog.log(Level.INFO, "Potion 0 " + recipes.getBreweryRecipe(PotionPlugin.water, new SimpleItem(Items.nether_wart)));
    		
            for (BreweryRecipe recipe : apotions)
                arecipes.add(new CachedBreweryRecipe(recipe));
    	} else
            super.loadCraftingRecipes(outputId, results);
    }

    @Override
    public void loadUsageRecipes(ItemStack ingredient) {
        if (ingredient.getItem() != potionitem && !ingredients.contains(ingredient)) return;
        /*
        for (BreweryRecipe recipe : apotions)
            if (NEIServerUtils.areStacksSameType(new ItemStack(recipe.input.getFluid().getBlock()), new ItemStack(recipe.item.getItem())) 
            		|| NEIServerUtils.areStacksSameType(new ItemStack(recipe.input.getFluid()), ingredient))
           
                arecipes.add(new CachedBrewingRecipe(recipe));
            */
    }

    @Override
    public void drawExtras(int recipe) {
        drawProgressBar(92, 5, 176, 0, 8, 30, 120, 1);
        drawProgressBar(60, 1, 185, -2, 12, 30, 35, 3);
    }

    public static void searchPotions() {
        TreeSet<Integer> allPotions = new TreeSet<Integer>();
        HashSet<Integer> searchPotions = new HashSet<Integer>();
        searchPotions.add(0);
        allPotions.add(0);
        do {
            HashSet<Integer> newPotions = new HashSet<Integer>();
            for (Integer basePotion : searchPotions) {
                if (ItemPotion.isSplash(basePotion))
                    continue;

                for (ItemStack ingred : ingredients.values()) {
                    int result = PotionHelper.applyIngredient(basePotion, ingred.getItem().getPotionEffect(ingred));

                    if (ItemPotion.isSplash(result)) {//splash potions qualify
                        addPotion(ingred, basePotion, result, allPotions, newPotions);
                        continue;
                    }

                    List<?> baseMods = potionitem.getEffects(basePotion);
                    List<?> newMods = potionitem.getEffects(result);//compare ID's
                    if (basePotion > 0 && baseMods == newMods || //same modifers and not water->empty
                            baseMods != null && (baseMods.equals(newMods) || newMods == null) || //modifiers different and doesn't lose modifiers
                            basePotion == result ||//same potion
                            levelModifierChanged(basePotion, result))//redstone/glowstone cycle
                        continue;

                    addPotion(ingred, basePotion, result, allPotions, newPotions);
                }
            }

            searchPotions = newPotions;
        }
        while (!searchPotions.isEmpty());

        API.setItemListEntries(potionitem, Iterables.transform(allPotions, new Function<Integer, ItemStack>()//override with only potions that can be crafted
        {
            @Override
            public ItemStack apply(Integer potionID) {
                return new ItemStack(potionitem, 1, potionID);
            }
        }));
        API.addSubset("Items.Potions", new ItemStackSet().with(potionitem));
        API.addSubset("Items.Potions.Splash", new ItemFilter()
        {
            @Override
            public boolean matches(ItemStack item) {
                return item.getItem() == potionitem && (item.getItemDamage() & 0x4000) != 0;
            }
        });

        ItemStackSet positivepots = new ItemStackSet();
        ItemStackSet negativepots = new ItemStackSet();
        ItemStackSet neutralpots = new ItemStackSet();

        for (int potionID : allPotions) {
            List<PotionEffect> effectlist = potionitem.getEffects(potionID);
            int type = 0;
            if (effectlist != null && !effectlist.isEmpty())
                for (PotionEffect potioneffect : effectlist)
                    if (Potion.potionTypes[potioneffect.getPotionID()].isBadEffect())
                        type--;
                    else
                        type++;

            (type == 0 ? neutralpots : type > 0 ? positivepots : negativepots).add(new ItemStack(potionitem, 1, potionID));
        }

        API.addSubset("Items.Potions.Positive", positivepots);
        API.addSubset("Items.Potions.Negative", negativepots);
        API.addSubset("Items.Potions.Neutral", neutralpots);
    }

    private static boolean levelModifierChanged(int basePotionID, int result) {
        int basemod = basePotionID & 0xE0;
        int resultmod = result & 0xE0;

        return basemod != 0 && basemod != resultmod;
    }

    private static void addPotion(ItemStack ingred, int basePotion, int result, TreeSet<Integer> allPotions, HashSet<Integer> newPotions) {
        /*
    	apotions.add(new BrewingRecipe(ingred, basePotion, result));
        if (allPotions.add(result))//it's new
            newPotions.add(result);
        */
    }

    @Override
    public String getOverlayIdentifier() {
        return "brewing";
    }
	
}
